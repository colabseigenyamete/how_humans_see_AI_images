<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AI画像識別実験（投げ縄版）</title>

  <!-- jsPsych -->
  <script src="https://unpkg.com/jspsych@7.3.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
  <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-slider-response"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form"></script>

  <style>
    body { font-family: sans-serif; }
    canvas { border: 1px solid #444; margin: 10px 0; }
    .btn {
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 5px;
      margin-right: 10px;
      cursor: pointer;
    }
    .btn:disabled {
      background: #aaa;
    }
  </style>
</head>
<body></body>

<script>

// ====== ★★★ 必ず書き換える ★★★ ======
const GAS_URL = "https://script.google.com/macros/s/AKfycbx3iuUEpzbbRYT3EL0UPPAEAIKgrN70iRxEWyXMrMfCjit9dQk6nXZCOPost71s5Rnr/exec";
// ========================================


// ------------------ jsPsych 初期化 ------------------
var jsPsych = initJsPsych({
  
});

var timeline = [];

// ---- 刺激リスト ----
var stimuli = [
  {stimulus: "stimuli/sample1.png"},
  {stimulus: "stimuli/sample2.png"}
];

// =====================================
//  各刺激ごとに trial を生成
// =====================================
stimuli.forEach(function(stim){

  // (1) 前提示
  let duration = jsPsych.randomization.sampleWithoutReplacement(
    [0.5,1,2,3,4,5,6], 1)[0];

  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    choices: [" "],
    data: {trial_type:"instruction", img:stim.stimulus, duration:duration},
    stimulus: `<p><b>${duration} 秒</b> 間画像を提示します。</p>
               <p>スペースキーで開始</p>`
  });

  // (2) 画像提示
  timeline.push({
    type: jsPsychImageKeyboardResponse,
    stimulus: stim.stimulus,
    choices: "NO_KEYS",
    trial_duration: duration * 1000,
    data: {trial_type:"image_presentation", img:stim.stimulus, duration:duration}
  });

  // (3) 初期スライダー
  timeline.push({
    type: jsPsychHtmlSliderResponse,
    stimulus: `<p>この画像はAI生成だと思いますか？</p>`,
    labels: ["完全に人間","かなり人間","やや人間","不明","ややAI","かなりAI","完全にAI"],
    min:0, max:6, start:3, step:1, require_movement:true,
    slider_width: 800,
    data: {trial_type:"initial_slider", img:stim.stimulus, duration:duration}
  });

  // (4) 初期理由
  timeline.push({
    type: jsPsychSurveyHtmlForm,
    preamble: `<p>初期判断の理由を記述してください</p>`,
    html: `<textarea name="reason_initial" rows="5" cols="60"></textarea>`,
    data: {trial_type:"initial_reason", img:stim.stimulus},
    on_finish: function(data){
      data.reason_initial = data.response.reason_initial;
      delete data.response;
    }
  });

  // (5) 再提示 + 複数投げ縄 + スライダー + 理由編集
  timeline.push({
    type: jsPsychHtmlSliderResponse,

    stimulus: function(){
      // 安全に前の理由を取得
      let prev = jsPsych.data.get()
        .filter({trial_type:"initial_reason"})
        .last(1)
        .values()[0];

      let initialText = prev && prev.reason_initial ? prev.reason_initial : "";

      return `
        <p>再度画像を提示します。怪しい箇所を自由に囲んでください（複数可）。</p>

        <canvas id="lassoCanvas"></canvas>
        <br>

        <button class="btn" id="finishLasso">囲み確定（1つ）</button>
        <button class="btn" id="resetLasso">やり直す</button>

        <p>最終判断の理由（編集可）</p>
        <textarea id="reason_final" rows="5" cols="60">${initialText}</textarea>
      `;
    },

    labels: ["完全に人間","かなり人間","やや人間","不明","ややAI","かなりAI","完全にAI"],
    min:0, max:6, start:3, step:1, require_movement:true,
    slider_width: 800,

    data: {trial_type:"final_reason", img:stim.stimulus, duration:duration},

    on_load: function(){

      // ===== Canvas Setup =====
      const canvas = document.getElementById("lassoCanvas");
      const ctx = canvas.getContext("2d");

      const img = new Image();
      img.src = stim.stimulus;

      // 保存用
      window.lassoList = [];  // ←複数 lasso をここへ保存
      let currentLasso = [];

      img.onload = function(){
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
      };

      // ---------- 描画 ----------
      let drawing = false;

      canvas.addEventListener("mousedown", e=>{
        drawing = true;
        currentLasso = [];

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        currentLasso.push({x:x, y:y});
      });

      canvas.addEventListener("mousemove", e=>{
        if(!drawing) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentLasso.push({x:x, y:y});

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0);

        // 過去の lasso を表示
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        for(const l of window.lassoList){
          ctx.beginPath();
          ctx.moveTo(l[0].x, l[0].y);
          for(const p of l) ctx.lineTo(p.x, p.y);
          ctx.closePath();
          ctx.stroke();
        }

        // 現在描画中
        ctx.strokeStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(currentLasso[0].x, currentLasso[0].y);
        for(const p of currentLasso) ctx.lineTo(p.x, p.y);
        ctx.stroke();
      });

      canvas.addEventListener("mouseup", ()=>{
        drawing = false;
      });

      // ---------- ボタン操作 ----------
      document.getElementById("finishLasso").onclick = function(){
        if(currentLasso.length > 1){
          window.lassoList.push(currentLasso);
        }
        // 再描画
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0);

        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        for(const l of window.lassoList){
          ctx.beginPath();
          ctx.moveTo(l[0].x, l[0].y);
          for(const p of l) ctx.lineTo(p.x, p.y);
          ctx.closePath();
          ctx.stroke();
        }
      };

      document.getElementById("resetLasso").onclick = function(){
        window.lassoList = [];
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0);
      };

    },

    on_finish: function(data){
      data.reason_final = document.getElementById("reason_final").value;
      data.lasso = window.lassoList;
    }

  });

});


// ======================
//   実験終了
// ======================
timeline.push({
  type: jsPsychHtmlKeyboardResponse,
  choices: "NO_KEYS",
  stimulus: `<p>実験は終了です。ありがとうございました。</p>
             <p>データは自動で Google Drive に保存されます。</p>`,

  on_finish: async function() {

    const allData = jsPsych.data.get().values();

    try {
      const response = await fetch(GAS_URL, {
        method: "POST",
        body: JSON.stringify(allData)
      });

      console.log("送信完了", response);

      alert("Google Drive にデータを保存しました！");
    } catch(err) {
      console.error("送信エラー:", err);
      alert("送信に失敗しました。ネットワークを確認してください。");
    }

  }
});


// Run
jsPsych.run(timeline);

</script>
</html>

